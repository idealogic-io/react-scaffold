{
  "Scaffold": "Scaffold",
  "Project scaffold is in build progress": "Project scaffold is in build progress",
  "Home": "Home",
  "Not found Page": "Not found Page",
  "Landing": "Landing",
  "Contracts Interactions": "Contracts Interactions",
  "Contracts Interactions lvl.2": "Contracts Interactions Lvl2",

  "ProjectDescription": {
    "article1": "This branch was forked from the basic web3 scaffold with the aim of creating a template for even faster creation and deployment of uncomplicated DApp applications. The project utilizes a set of libraries including Rainbow-kit, wagmi, and view, which \"out-of-the-box\" fully take over the management and handling of all issues related to connecting the application to the web3 network, reading and writing data in the web3 network, multicalls, and many other functions.",
    "article2": "One downside of this approach is that it's quite challenging to customize the blockchain interaction logic if the project requires any non-standard solutions in this regard, as all the \"under-the-hood\" logic is handled by the libraries. Therefore, for creating large and complex DApps that require equally complex and non-standard solutions, using this scaffold is not recommended due to customization difficulties.",
    "article3": "This scaffold is perfectly suited for small DApps with straightforward logic and allows for significantly reducing the time-to-market and the development time."
  },

  "WalletButton": {
    "connect": "Connect Wallet",
    "unsupported": "Unsupported Network"
  },

  "SignInButton": {
    "signIn": "Sign In"
  },

  "ContractReadExample": {
    "tokenBalance": "Your balance of {{tokenName}} token: <bold>{{balance}} {{tokenSymbol}}</bold>",
    "article1": "In this section, we've covered the most basic point data retrieval from the blockchain and smart contracts using hooks provided by Wagmi. It's absolutely nothing complicated. All the details about working with the data reading hook from the smart contract are well documented in the Wagmi documentation (see the link on the landing page). It's worth paying attention to the \"watch\" parameter, which allows for real-time data updates as new blocks are added to the network. If real-time updating is not necessary, this parameter can be omitted for more optimal resource consumption. Also, it's important to note that all numeric data retrieved from the smart contract, which you plan to use in any calculations, is highly recommended to be wrapped in Bignumber.js for subsequent ease of use."
  },

  "ContractWriteExample": {
    "mint": "Mint 100 SCT",
    "scanner": "See your transaction in scanner",
    "article1": "In this section, we cover the simplest invocation of a transaction through a smart contract. Using Wagmi hooks, we handle the full transaction cycle in the most straightforward way. For instance, the <bold>usePrepareContractWrite()</bold> hook is responsible for preparing the transaction data and estimating the likelihood of its successful execution. If the transaction is likely to fail for some reason, the isSuccess parameter will become negative at this stage (this can be used as a marker to disable the button responsible for the call). If everything is fine at this stage, the <bold>useContractWrite()</bold> hook comes into play, which can take configurations from the previous hook. It provides numerous parameters, but in this example, we focus only on the invocation function, which comes in two types: synchronous and asynchronous. I prefer the asynchronous one, as it's more comfortable to handle the further part of the transaction's life cycle. After calling this function, in a successful flow, we will receive the hash of the new transaction. And this hash can be used in the third hook - <bold>useWaitForTransaction()</bold>. This hook waits for the final result of the transaction and returns the corresponding data. And only after this stage, we can say that the life cycle of the transaction is complete."
  },

  "ContractExampleLvl2": {
    "staked": "You've staked: {{amount}} {{tokenName}}.",
    "reward": "Your current available reward is: {{amount}} {{tokenName}}.",
    "claim": "Claim reward!",
    "tokenBalance": "You are available to stake: {{balance}} {{tokenSymbol}}.",
    "max": "Max",
    "approve": "Approve",
    "stake": "Stake",
    "stakeAmount": "Stake amount",
    "unstake": "Unstake my {{amount}} {{tokenName}}",
    "article1": "In this section, an example of a more complex but more realistic scenario for reading and writing data in the blockchain is demonstrated. It showcases interaction with a staking smart contract, where a user can deposit funds and earn rewards over time. For data retrieval, a multicall was used, allowing the consolidation of all the required blockchain get-requests into a single request. It's important to note that these requests can target entirely different smart contracts, with the main condition being that they all reside on the same network. Otherwise, a separate multicall instance is required for each network. For writing data, the same hook as in the previous section was used, but this time, an additional hook for handling input data and a \"Max\" button was also utilized. Moreover, this hook helps to differentiate between two scenarios: when an approval is needed (see Allowance in ERC-20) and when it isn't."
  }
}
